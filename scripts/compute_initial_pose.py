
import torch
import argparse
from flexfold.models import struct_to_crd
from cryodrgn.mrcfile import write_mrc, parse_mrc
from flexfold.core import vol_real, vol_ft, register_crd_to_vol,matrix2euler, struct_to_pdb
import torch
from openfold.utils.tensor_utils import tensor_tree_map

from cryodrgn import fft
import sys
import os
from Bio.PDB import PDBParser, Superimposer, is_aa,PDBIO
import numpy as np

# Select atoms (e.g., CA atoms for proteins)
def get_ca_atoms(structure):
    atoms = []
    for model in structure:
        for chain in model:
            for residue in chain:
                if is_aa(residue, standard=True) and "CA" in residue:
                    atoms.append(residue["CA"])
    return atoms

def get_coords(atoms):
    return torch.tensor([a.get_coord() for a in atoms])
        

def main(args):

    outfile = args.outdir + ".pt"
    if os.path.isfile(outfile) and not args.overwrite:
        print("Path exists : %s "%(outfile))
        print("Exiting ...")
        sys.exit()

    #############################################################
    # 3 ways to get initial pose :
    # 1) (auto) from embeddings path produced by AF inference --embedding_path
    # 2) (auto) from PDB generated by AF inference or other --embedding_pdb_path
    # 3) (manual) from PDB already aligned to the backporjected map --from_align_pdb

    if args.from_aligned_pdb is not None:
    # METHOD 3 ------------------------------------------------------------------------
        parser = PDBParser(QUIET=True)
        structure1 = parser.get_structure("ref", args.alignment_reference)
        structure2 = parser.get_structure("mobile", args.from_aligned_pdb)
        atoms1 = get_ca_atoms(structure1)
        atoms2 = get_ca_atoms(structure2)

        # Superimpose and calculate RMSD
        sup = Superimposer()
        sup.set_atoms(atoms2, atoms1)  # This aligns atoms2 onto atoms1
        R_final, shift_final = sup.rotran
        angle_final = matrix2euler(R_final)

        #to tensors
        R_final = torch.tensor(R_final)
        shift_final = torch.tensor(shift_final)
        angle_final = torch.tensor(angle_final)
    else:

        device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        print(f"Using device: {device}")

        if args.embedding_pdb_path:
    # METHOD 2 ------------------------------------------------------------------------
            parser = PDBParser(QUIET=True)
            structure = parser.get_structure("ref", args.embedding_pdb_path)
            atoms = get_ca_atoms(structure)
            crd = get_coords(atoms).to(device)
        elif args.embedding_path:
    # METHOD 1 ------------------------------------------------------------------------
            embeddings = torch.load(args.embedding_path, map_location=device)
            crd = embeddings["final_atom_positions"]
            crd = struct_to_crd(embeddings, ca=True)


        if args.dist_search == -1:
            R_final = torch.eye(3, device=crd.device, dtype=crd.dtype)
            shift_final = torch.zeros(3, device=crd.device, dtype=crd.dtype)
            angle_final = torch.zeros(3, device=crd.device, dtype=crd.dtype)
        else:
            vol_ext, header = parse_mrc(args.backproject_path)
            vol_ext = torch.tensor(vol_ext).to(device)
            vol_ext = fft.fftn_center(vol_ext)
            assert(vol_ext.shape[-1] == vol_ext.shape[-2] == vol_ext.shape[-3])
            angle_final, R_final, shift_final = register_crd_to_vol(
                vol = vol_ext,
                crd=crd, 
                grid_size=vol_ext.shape[-1], 
                sigma=args.sigma, 
                pixel_size=args.pixel_size, 
                dist_search = args.dist_search,
                real_space = args.real_space
            )

    torch.save({"R": R_final, "T":shift_final}, outfile)

    print("Translation (Angstroms) : %s"%str(shift_final))
    print("Angle (degrees) : %s"%str(angle_final))
    print("Rotation matrix  : %s"%str(R_final))


    print("Successfully written %s"%( args.outdir+".pt"))

    if args.from_aligned_pdb:
        sup.apply(structure2.get_atoms())  # transforms all atoms of structure2

        # Write the aligned structure to a new PDB
        io = PDBIO()
        io.set_structure(structure2)
        io.save(args.outdir+".pdb")
    else:
        if args.embedding_pdb_path:
            for atom in structure.get_atoms():
                atom.coord = atom.coord @ R_final.cpu().numpy() + shift_final.cpu().numpy()

            # Save the transformed structure
            io = PDBIO()
            io.set_structure(structure)
            io.save( args.outdir+".pdb")
        elif args.embedding_path:
            embeddings["final_atom_positions"] = embeddings["final_atom_positions"] @ R_final + shift_final
            struct_to_pdb(tensor_tree_map(lambda x: x.detach().cpu().numpy(), embeddings),  args.outdir+".pdb")

    print("Successfully written %s"%( args.outdir+".pdb"))

if __name__ == "__main__":
    parser = argparse.ArgumentParser()

    parser.add_argument( "outdir", type=str,help="")

    parser.add_argument( "--backproject_path", type=str,help="")
    parser.add_argument( "--embedding_path", type=str,help="")
    parser.add_argument( "--embedding_pdb_path", type=str,help="")
    parser.add_argument( "--dist_search", type=float,help="")
    parser.add_argument( "--grid_size", type=int,help="")
    parser.add_argument( "--pixel_size", type=float,help="")
    parser.add_argument( "--sigma", type=float,help="")
    parser.add_argument( "--overwrite",  action="store_true")
    parser.add_argument( "--real_space",  action="store_true")

    parser.add_argument( "--from_aligned_pdb", type=str,help="", default=None)
    parser.add_argument( "--alignment_reference", type=str,help="", default=None)

    args = parser.parse_args()
    main(args)